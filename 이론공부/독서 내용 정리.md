# 자바 기반의 마이크로 서비스 이해와 아키텍처 구축하기
- 아키텍쳐가 필요한 이유는 이해관계자마다 다르게 해석할 수 있기 때문.
- 아키텍쳐 스타일은 접근 방법을 제시하고 아키텍처 패턴은 문재 해결 방법을 제시하는 것
  - MSA도 모놀리스 구조의 문제점을 해결하기 위한 접근방법에 해당하는 스타일.
- 모놀리식의 문제점
  - 수정 시 수정하지 않은 부분도 빌드를 하기 때문에 빌드가 오래 걸린다.
  - 과거에는 플랫폼 서비스가 지금 수준이 되지 않기 때문에 모놀리식이 최적이였다.
  - 기능 일부에 문제가 생기면 애플리케이션 전체가 작동하지 않는다.
    - 이것은 MSA에도 없어지지는 않지만 MSA에서는 서비스 확장에 탄력성을 가져 유연하게 대처할 수 있다.
### 🤔 SOA vs MSA
- 공통점
  - 소프트웨어를 설계할 때 서비스 중심의 설계
- 차이점
- 첫번째
  - SOA는 비즈니스 측면에서 서비스의 재사용성을 강조
  - MSA는 한가지의 서비스에 집중
- 두번째
  - 서비스 오너십 측면에서 MSA는 하나의 독립된 팀에서 개발하고 관리.
  - SOA는 비즈니스 프로세스 흐름과 관련된 서비스를 공유하고 연결 및 조합하기 때문에 팀간에 상호 협업이 반드시 필요
- 세번째
  - MSA는 서비스 공유의 최소화 지향
  - SOA는 되도록 많은 서비스의 공유를 지향
- 네번째
  - MSA는 서비스를 공유하지 않고 독립되어 실행되는 것을 지향(REST API)
  - SOA는 ESB(Enterprise Service Bus)사용

## 클라우드 네이티브
- 클라우드 네이티브 애플리케이션이란 환경 변화에 민첩하고 능동적으로 대응하기 위해서 클라우드 네이티브 환경에 SaaS나 Faas 형태로 서비스 되는 애플리케이션을 의미한다.
> ✔ SaaS와 모놀리스의 차이점\
> 기존 모놀리스 환경은 특성 사이트 혹은 사용자들의 요구 조건에 따라 딱 맞게 만들어진다면
> SaaS는 불특정 다수가 사용할 것을 고려해야한다.

### 12 Factors
1. 코드베이스
   - 하나의 어플리케이션은 하나의 코드베이스를 가지고 추적, 관리되어야 한다.
   - 코드베이스란 원본 코드를 말하며 여러 단계(개발, 테스트, 배포)로 배포될 수 있지만 원천 소스는 하나
2. 종속성
   - 라이브러리들은 암묵적인 종속성이 발생하지 않아야 한다. 사용하는 라이브러리는 명시적으로 선언한다.
3. 환경 설정
   - 코드에서 사용하는 환경 설정은 코드와 완전히 분리되어야 한다.
4. 백엔드 서비스
   - 백엔드 서비스는 모두 리소스로 취급한다. 연결하거나 분리할 때 코드를 수정하지 않고 연결해야 한다. 백엔드 서비스를 구별하기 위한 리소스 식별자는 URI.
5. 빌드, 릴리스 및 실행
   - 빌드는 코드를 실행 가능한 형태로 변환, 빌드는 라이브러리들이 결합하여 컴파일, 릴리즈는 즉시 실행이 가능한 형태로 만드는 과정.
6. 프로세스
   - 프로세스는 stateless로 실행되어 상태를 공유하지 않아야 한다. 프로그램에 사용한 데이터가 캐싱되어 다음 수행에도 참조되지 않아야한다.
7. 포트 바인딩
   - 애플리케이션은 독립된 서비스로 동작할 수 있어 다른 서비스의 백엔드 서비스로도 활용이 될 수 있다.
8. 동시성
   - 시스템에 부하가 생기면 수용 용량을 늘리기 보다는 수평적 확장이 가능해야한다.
9. 폐기 가능
   - 비정상적인 프로세스의 종료에도 실행 중이던 작업은 안전하게 종료되어야 한다. 즉 시스템 상황에 대응이 잘 되어야 한다.
10. 개발, 테스트, 운영 환경의 일관성
    - 환경 차이의 문제가 없도록 모두 같은 환경에서 진행될 수 있어야 한다.
11. 로그
    - 로그는 스트림이벤트로 취급하여 애플리케이션에서 로그 처리에 관여하거나 가공 및 관리하여 해서는 안된다.
12. 일회성 프로세스
    - 일회성 작업은 구분하여 별도의 프로세스로 구성한다.

### 지속적 통합 배포
- CI(Continous Integration)
  - 일반적인 CI 절차
  1. 개발자가 개발하여 소스 코드를 저장소(Git)에 저장
  2. 빌드 도구로 소스 빌드
  3. 실행 환경에 배포
- CD
  - continuous delivery와 continuous deployment 두가지 유형이 있다.
  - 실행 환경으로 배포 직전까지 배포하여 담당자가 수동 반영하거나 실행까지 배포하는 것.
- 배포 파이프라인
  - 빌드, 통합 테스트, 배포까지의 프로세스를 하나로 연결하여 자동화 구축.
  - 되도록 서비스 별로 하나씩
- 카나리 배포와 블루그린 배포
  - 카나리 배포
    - 새 버전의 서비스를 일부 사용자에게만 배포하여 정상 유무를 확인
  - 블루 그린 배포
    - 새로운 버전을 라우팅. 문제 유무에 따라 버전 변경.

### 작은 서비스
- 서비스를 식별하기 위해 도메인 주도 설계의 `바운디드 콘텍스트`와 `보편적 언어`라는 용어로 서비스의 경계를 나누고 식별한다.
- 보편적 언어
  - 하는 업무에 따라 단어에 대한 해석이 다를 수 있는데 이에 따라 서비스를 분리하는 것.(ex 고객)
- 바운디드 콘텍스트
  - 독립적으로 실행될 수 있고 결합이 없는 서비스는 다른 서비스의 문제에 영향을 받지 않는다.
> 해당 부분은 도메인 주도 설계에 대한 공부가 더 필요할 것 같다.

### 사용자 유형 분석
- 사용자 유형을 분석하는 것은 도메인 비즈니스 이해의 첫단계
- 사용자를 어떻게 분류하는지, 명칭을 어떻게 하는지, 역할이 무엇인지, 권한이 어떤지, 속한 조직이 있는지 등으로 사용자를 정의할 수 있다.

### 업무 흐름의 분석
- 데이터 간의 관계를 배제하고 업무의 흐름을 분석한다.
- 순서를 구분하여 별도의 서비스로 가정한다.
- 데이터를 참조할 일이 생기면 실시간 참조인지 시간 간격이 있어도 되는지 등 흐름을 기준으로 경계를 나눈다.

### 핵심 업무 및 우선순위
- 업무 내용에 따라 기능들을 특화(핵심 비즈니스), 일반(알림, 설문 등), 공용(인증, 사용자관리 등 대부분 시스템이 제공하는 기능)

### 상관 분석
- 서비스 간 포함 관계나 참조 관계를 파악하여 수평적 관계로 변경한다.
- 포함 관계를 제거하여 한가지 일에 집중할 수 있도록 한다.
- 만약 분리된 서비스가 독립적으로 실행될 수 없는 구조라면 분리할 수 없는 서비스로 호출하는 서비스와 동일한 서비스가 된다.
- 데이터의 상관관계도 최소 스키마 단위로라도 분리한다.
- 다른 서비스의 데이터는 직접 참조해서는 안된다.

### 서비스 경계 💀
- 논리적인 접근을 통해 최적의 형태가 결정되어야 한다.
- 중요한 것은 분할 기준이 있어야 한다. 조직을 기준? 서비스 업무 중요도 기준?

### 서비스 분할
1. 하향식 접근
   - 업무의 흐름을 기준으로 핵식, 비핵심점인 업무를 나누고 어느 도메인에서나 사용가능한 업무로 나누어 서비스로 정의한다.
   - 이것은 서비스에 사용하기 위한 데이터를 서비스 별로 정의하는 접근법이다.
2. 상향식 접근
   - 데이터의 특성을 고려하여 분할하는 것.
   - 데이터를 기준으로 연관성이 없는 부분부터 분리하고 이를 사용하는 서비스 별로 분리
3. 점진적 분할
   - 비즈니스 영향이 적은 부분부터 하나씩 점진적으로 변경
   - 문제가 없다면 건드리지 않는게 최고!..

### 데이터 간의 종속성
- 분할된 서비스끼리 데이터를 어떻게 처리해야 하는가?
  - 설계 단계에서 처리하거나 큐를 사용하여 데이터를 동기화한다.