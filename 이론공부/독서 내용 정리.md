# 자바 기반의 마이크로 서비스 이해와 아키텍처 구축하기
- 아키텍쳐가 필요한 이유는 이해관계자마다 다르게 해석할 수 있기 때문.
- 아키텍쳐 스타일은 접근 방법을 제시하고 아키텍처 패턴은 문재 해결 방법을 제시하는 것
  - MSA도 모놀리스 구조의 문제점을 해결하기 위한 접근방법에 해당하는 스타일.
- 모놀리식의 문제점
  - 수정 시 수정하지 않은 부분도 빌드를 하기 때문에 빌드가 오래 걸린다.
  - 과거에는 플랫폼 서비스가 지금 수준이 되지 않기 때문에 모놀리식이 최적이였다.
  - 기능 일부에 문제가 생기면 애플리케이션 전체가 작동하지 않는다.
    - 이것은 MSA에도 없어지지는 않지만 MSA에서는 서비스 확장에 탄력성을 가져 유연하게 대처할 수 있다.
### 🤔 SOA vs MSA
- 공통점
  - 소프트웨어를 설계할 때 서비스 중심의 설계
- 차이점
- 첫번째
  - SOA는 비즈니스 측면에서 서비스의 재사용성을 강조
  - MSA는 한가지의 서비스에 집중
- 두번째
  - 서비스 오너십 측면에서 MSA는 하나의 독립된 팀에서 개발하고 관리.
  - SOA는 비즈니스 프로세스 흐름과 관련된 서비스를 공유하고 연결 및 조합하기 때문에 팀간에 상호 협업이 반드시 필요
- 세번째
  - MSA는 서비스 공유의 최소화 지향
  - SOA는 되도록 많은 서비스의 공유를 지향
- 네번째
  - MSA는 서비스를 공유하지 않고 독립되어 실행되는 것을 지향(REST API)
  - SOA는 ESB(Enterprise Service Bus)사용

## 클라우드 네이티브
- 클라우드 네이티브 애플리케이션이란 환경 변화에 민첩하고 능동적으로 대응하기 위해서 클라우드 네이티브 환경에 SaaS나 Faas 형태로 서비스 되는 애플리케이션을 의미한다.
> ✔ SaaS와 모놀리스의 차이점\
> 기존 모놀리스 환경은 특성 사이트 혹은 사용자들의 요구 조건에 따라 딱 맞게 만들어진다면
> SaaS는 불특정 다수가 사용할 것을 고려해야한다.

### 12 Factors
1. 코드베이스
   - 하나의 어플리케이션은 하나의 코드베이스를 가지고 추적, 관리되어야 한다.
   - 코드베이스란 원본 코드를 말하며 여러 단계(개발, 테스트, 배포)로 배포될 수 있지만 원천 소스는 하나
2. 종속성
   - 라이브러리들은 암묵적인 종속성이 발생하지 않아야 한다. 사용하는 라이브러리는 명시적으로 선언한다.
3. 환경 설정
   - 코드에서 사용하는 환경 설정은 코드와 완전히 분리되어야 한다.
4. 백엔드 서비스
   - 백엔드 서비스는 모두 리소스로 취급한다. 연결하거나 분리할 때 코드를 수정하지 않고 연결해야 한다. 백엔드 서비스를 구별하기 위한 리소스 식별자는 URI.
5. 빌드, 릴리스 및 실행
   - 빌드는 코드를 실행 가능한 형태로 변환, 빌드는 라이브러리들이 결합하여 컴파일, 릴리즈는 즉시 실행이 가능한 형태로 만드는 과정.
6. 프로세스
   - 프로세스는 stateless로 실행되어 상태를 공유하지 않아야 한다. 프로그램에 사용한 데이터가 캐싱되어 다음 수행에도 참조되지 않아야한다.
7. 포트 바인딩
   - 애플리케이션은 독립된 서비스로 동작할 수 있어 다른 서비스의 백엔드 서비스로도 활용이 될 수 있다.
8. 동시성
   - 시스템에 부하가 생기면 수용 용량을 늘리기 보다는 수평적 확장이 가능해야한다.
9. 폐기 가능
   - 비정상적인 프로세스의 종료에도 실행 중이던 작업은 안전하게 종료되어야 한다. 즉 시스템 상황에 대응이 잘 되어야 한다.
10. 개발, 테스트, 운영 환경의 일관성
    - 환경 차이의 문제가 없도록 모두 같은 환경에서 진행될 수 있어야 한다.
11. 로그
    - 로그는 스트림이벤트로 취급하여 애플리케이션에서 로그 처리에 관여하거나 가공 및 관리하여 해서는 안된다.
12. 일회성 프로세스
    - 일회성 작업은 구분하여 별도의 프로세스로 구성한다.

### 지속적 통합 배포
- CI(Continous Integration)
  - 일반적인 CI 절차
  1. 개발자가 개발하여 소스 코드를 저장소(Git)에 저장
  2. 빌드 도구로 소스 빌드
  3. 실행 환경에 배포
- CD
  - continuous delivery와 continuous deployment 두가지 유형이 있다.
  - 실행 환경으로 배포 직전까지 배포하여 담당자가 수동 반영하거나 실행까지 배포하는 것.
- 배포 파이프라인
  - 빌드, 통합 테스트, 배포까지의 프로세스를 하나로 연결하여 자동화 구축.
  - 되도록 서비스 별로 하나씩
- 카나리 배포와 블루그린 배포
  - 카나리 배포
    - 새 버전의 서비스를 일부 사용자에게만 배포하여 정상 유무를 확인
  - 블루 그린 배포
    - 새로운 버전을 라우팅. 문제 유무에 따라 버전 변경.

### 작은 서비스
- 서비스를 식별하기 위해 도메인 주도 설계의 `바운디드 콘텍스트`와 `보편적 언어`라는 용어로 서비스의 경계를 나누고 식별한다.
- 보편적 언어
  - 하는 업무에 따라 단어에 대한 해석이 다를 수 있는데 이에 따라 서비스를 분리하는 것.(ex 고객)
- 바운디드 콘텍스트
  - 독립적으로 실행될 수 있고 결합이 없는 서비스는 다른 서비스의 문제에 영향을 받지 않는다.
> 해당 부분은 도메인 주도 설계에 대한 공부가 더 필요할 것 같다.

### 사용자 유형 분석
- 사용자 유형을 분석하는 것은 도메인 비즈니스 이해의 첫단계
- 사용자를 어떻게 분류하는지, 명칭을 어떻게 하는지, 역할이 무엇인지, 권한이 어떤지, 속한 조직이 있는지 등으로 사용자를 정의할 수 있다.

### 업무 흐름의 분석
- 데이터 간의 관계를 배제하고 업무의 흐름을 분석한다.
- 순서를 구분하여 별도의 서비스로 가정한다.
- 데이터를 참조할 일이 생기면 실시간 참조인지 시간 간격이 있어도 되는지 등 흐름을 기준으로 경계를 나눈다.

### 핵심 업무 및 우선순위
- 업무 내용에 따라 기능들을 특화(핵심 비즈니스), 일반(알림, 설문 등), 공용(인증, 사용자관리 등 대부분 시스템이 제공하는 기능)

### 상관 분석
- 서비스 간 포함 관계나 참조 관계를 파악하여 수평적 관계로 변경한다.
- 포함 관계를 제거하여 한가지 일에 집중할 수 있도록 한다.
- 만약 분리된 서비스가 독립적으로 실행될 수 없는 구조라면 분리할 수 없는 서비스로 호출하는 서비스와 동일한 서비스가 된다.
- 데이터의 상관관계도 최소 스키마 단위로라도 분리한다.
- 다른 서비스의 데이터는 직접 참조해서는 안된다.

### 서비스 경계 💀
- 논리적인 접근을 통해 최적의 형태가 결정되어야 한다.
- 중요한 것은 분할 기준이 있어야 한다. 조직을 기준? 서비스 업무 중요도 기준?

### 서비스 분할
1. 하향식 접근
   - 업무의 흐름을 기준으로 핵식, 비핵심점인 업무를 나누고 어느 도메인에서나 사용가능한 업무로 나누어 서비스로 정의한다.
   - 이것은 서비스에 사용하기 위한 데이터를 서비스 별로 정의하는 접근법이다.
2. 상향식 접근
   - 데이터의 특성을 고려하여 분할하는 것.
   - 데이터를 기준으로 연관성이 없는 부분부터 분리하고 이를 사용하는 서비스 별로 분리
3. 점진적 분할
   - 비즈니스 영향이 적은 부분부터 하나씩 점진적으로 변경
   - 문제가 없다면 건드리지 않는게 최고!..

### 데이터 간의 종속성
- 분할된 서비스끼리 데이터를 어떻게 처리해야 하는가?
  - 설계 단계에서 처리하거나 큐를 사용하여 데이터를 동기화한다.

# MSA 컴포넌트
### 모놀리식 아키텍처 장점
- 시스템 운영과 개발이 편리하다
  - 하나의 WAS에서 모든 기능을 처리
  - 하나의 데이터 저장소 사용
    - RDB의 트랜잭션을 쉽게 사용할 수 있다.
  - 테스트 환경을 구성하기 쉽다.
  - 코드베이스가 하나이기 때문에 개발자는 클래스 단위로 개발하며 객체간 정보를 주고받는데
    - MSA는 네트워크를 통해 통신하여 지연이나 데이터 유실을 고려해야함

### 모놀리식 아키텍처 단점
- 서비스 기능이 많아질수록 스파게티 코드가 되기 쉽다.
- 웹 서비스의 경우 동적 html을 제공하기 위해 jsp나 Thymeleaf를 사용해야한다.
  - 코드베이스에서 클라이언트와 서버 둘 다 가지고 있어야 한다.
  - 클라이언트 기능이 수정되었는데 서버를 재시작 해야한다.
  - AOS, IOS를 위한 REST-API 기능을 구현하기 위해 직렬화/역직렬화가 필요
    - 비즈니스 영역의 핵심 기능이 아니기 때문에 DDD에서의 도메인 영역이 아님
    - 따라서 소스코드와 복잡도 증가
- 비효율적인 스케일 아웃일 수 있다.
  - 스케일 아웃 시, 잘 사용되지 않는 기능까지 늘리게 될 수 있다.

### MSA 장점
- 독립성
  - MS는 하나의 비즈니스 기능을 담당하여 다른 서비스와 간섭이 최소화.
- 대용량 데이터 처리에 용이
  - RDB의 경우 스케일 아웃이 쉽지 않아 데이터 샤딩이나 레플리카를 구성한다.
  - 샤딩의 경우 운영의 어려움이 생기고 레플리카의 경우 클러스터로 관리하여 늘어날수록 리소스가 필요해 한계가 있다.
  - NOSQL도 성능 향상의 한계가 있고 (제품마다 다르지만) 여러 노드에 분산하여 저장해 확장시 리밸런싱을 해야하는데 부하가 높아진다.
  - 마이크로 서비스는 각 서비스가 저장소를 가지며 샤딩이나 캐시를 서비스 단위로 적용할 수 있다.
- 시스템 장애에 견고
  - 모놀리식의 경우 스케일 아웃과 고가용성으로 대비하여 문제가 생긴 장비를 격리한다.
    - 다수 장비에 문제가 생기거나 버그 발생 시 서비스를 이용할 수 없음
  - MSA의 경우 버그가 생겨도 해당 서비스만 사용 불가능
  - 몰론 개발자는 두 경우에 대비해야하지만 MSA가 덜 치명적이다.
  - 클라우드와 결합 시 탄력 회복성을 가져 인스턴스를 자동으로 추가 가능
- 배포 주기가 빠름
  - 모놀리식의 경우 가장 오래 걸리는 기능에 배포 일정을 맞춘다.
  - MSA는 필요한 기능만 먼저 배포할 수 있다.
  - 이것은 아키텍처로만 가능한 것이 아니라 CI/CD를 구축해야 빠른 배포가 가능하다.
    1. 개발자가 git에 코드 커밋
    2. git이 jira에 커밋 결과 반영
    3. git이 젠킨스 CI에 코드빌드, 유닛테스트, 통합테스트 진행
    4. 젠킨스는 테스트 결과를 알림
    5. 젠킨스는 Dev나 Stage환경에 배포
    6. Production 환경에 배포
- 확장성
  - 필요한 서비스만 확장 가능
- 민첩한 대응

> 샤딩이 뭐죠?
> 데이터들을 샤드라는 단위로 여러 DB 인스턴스에 나누어 관리하는 것.
> 데이터는 샤드의 숫자만큼 분류하여 저장하는데 이때 분류 알고리즘 사용.
> 고가용성을 위해 마스터-슬레이브 구조이며 모두 같은 테이블과 제약을 가진다.
> 원하는 데이터를 찾기 위해 서버와 알고리즘을 공유할 수 있지만 수정이 힘들다.
> 로케이션 방식은 위치를 중앙에서 관리하여 위치를 질의 후 접근하여 질의한다.
> 두번 질의하여 리소스가 2배지만 한곳에 몰릴 때 리밸런싱 작업이 용이하다.

### MSA 단점
- 개발하기 어렵다
  - 네트워크상에 분산된 것을 고려해야 한다.
    - RDB의 트랜잭션 사용 불가능
    - 네트워크는 신뢰할 수 없고 커넥션은 비싸다.
      - 커넥션 풀 사용하여 타임아웃 고려
      - 직렬화/역직렬화 비용 발생
- 운영하기 어렵다
  - 수많은 마이크로서비스가 통합되어야한다.
  - 데이터 일관성 유지하기 어렵다
    - SAGA 패턴(개발 난이도 증가)
- 설계하기 어렵다
  - 마이크로 서비스의 관계가 명확하지 않으면 데이터들이 중복된다.
    - 데이터 파편화로 일관성을 유지하기 어렵다.
    - 과도한 네트워크 통신이 발생한다.
- 여러가지 자동화 시스템 필요
  - 장점을 얻기 위해 CI/CD, 모니터링, 로그 통합 시스템이 필요하다.
- 개발자의 기술력 필요
  - 개발 속도는 개발자 숫자에 비례하지 않는다.
    - 많아질수록 의사소통 비용 증가


### 서비스 세분화
- 비즈니스 기능
- 성능
- 메시지 크기
- 트랜잭션

## Why Spring Boot?
- 웹 서비스를 제공하는 프레임워크
  - 스프링 웹 MVC 프레임워크
  - 스프링 부트 프레임워크
  - 스파크 웹 서버 프레임워크
  - 네티 프레임워크
- 스프링 부트는 쉽게 확장할 수 있는 생태계(eco-system), MSA에 적합, 12 factors 구현 용이, 대중적, 참고 문서가 많음

### 스프링과 스프링 부트의 차이점
- 스프링
  - 엔터프라이즈 어플리케이션(비즈니스 로직이 복잡하거나 여러 기능을 통합한)을 개발하기 위한 경량 프레임워크
  - 두 개 이상의 재사용 가능한 시스템 컴포넌트로 구성됨
  - 스프링 이전에는 EJB(Enterprise JavaBeans)사용.
    - 프레임워크의 코드와 개발자 코드가 복잡하게 얽힘
    - 스프링의 경우 그렇지 않아 비침투적 프레임워크라고도 한다.
- 스프링 부트
  - 스프링 프레임워크를 쉽게 사용할 수 있도록 편의 기능을 제공하는 프레임워크
  - 자동 구성(auto configuration), 스타터기능, actuator가 있음
  - 배치나 비동기 애플리케이션도 가능하다.

> 자세한 스프링 특징은 별도로 공부하자